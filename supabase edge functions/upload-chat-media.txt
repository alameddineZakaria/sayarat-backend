const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

// Simple base64 decode without any external dependencies
function decodeBase64(base64: string): Uint8Array {
  const binaryStr = atob(base64);
  const bytes = new Uint8Array(binaryStr.length);
  for (let i = 0; i < binaryStr.length; i++) {
    bytes[i] = binaryStr.charCodeAt(i);
  }
  return bytes;
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  const supabaseUrl = Deno.env.get('SUPABASE_URL');
  const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

  if (!supabaseUrl || !supabaseServiceKey) {
    return new Response(
      JSON.stringify({ error: 'Server configuration error' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  try {
    const body = await req.json();
    let { base64Data, fileName, userId, mediaType } = body;
    
    if (!base64Data) {
      return new Response(
        JSON.stringify({ error: 'No media data provided' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
    
    // Remove data URL prefix if present
    if (base64Data.includes(',')) {
      base64Data = base64Data.split(',')[1];
    }
    
    // Remove any whitespace or newlines
    base64Data = base64Data.replace(/\s/g, '');
    
    // Determine bucket and content type
    let bucket = 'voice-messages';
    let contentType = 'audio/webm';
    let finalFileName = fileName || `media_${userId || 'anon'}_${Date.now()}`;
    
    if (mediaType === 'image') {
      bucket = 'vehicle-images';
      contentType = base64Data.startsWith('/9j/') ? 'image/jpeg' : 
                    base64Data.startsWith('iVBOR') ? 'image/png' : 'image/jpeg';
      finalFileName = `chat/${finalFileName}`;
    } else if (mediaType === 'voice') {
      bucket = 'voice-messages';
      contentType = base64Data.startsWith('GkXfo') ? 'audio/webm' : 'audio/m4a';
    }
    
    // Decode base64 using native atob
    const bytes = decodeBase64(base64Data);
    
    if (bytes.length === 0) {
      return new Response(
        JSON.stringify({ error: 'Decoded data is empty' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Upload using fetch directly
    const uploadUrl = `${supabaseUrl}/storage/v1/object/${bucket}/${finalFileName}`;
    
    const uploadResponse = await fetch(uploadUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${supabaseServiceKey}`,
        'Content-Type': contentType,
        'x-upsert': 'true',
      },
      body: bytes,
    });

    if (!uploadResponse.ok) {
      const errorText = await uploadResponse.text();
      return new Response(
        JSON.stringify({ error: 'Upload failed', details: errorText }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const publicUrl = `${supabaseUrl}/storage/v1/object/public/${bucket}/${finalFileName}`;

    return new Response(
      JSON.stringify({ success: true, path: finalFileName, publicUrl }),
      { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: 'Failed to process upload', details: String(error) }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
