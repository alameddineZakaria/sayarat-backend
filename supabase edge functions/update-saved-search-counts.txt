
export const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

interface SavedSearch {
  id: string;
  user_id: string;
  name: string;
  search_query: string | null;
  filters: {
    make?: string;
    bodyType?: string;
    priceRange?: string;
    location?: string;
    condition?: string;
    transmission?: string;
    fuelType?: string;
    minPrice?: string;
    maxPrice?: string;
    minYear?: string;
    maxYear?: string;
    distance?: number;
    color?: string;
  };
  current_match_count: number;
  last_match_count: number;
  last_viewed_at: string | null;
  new_matches_since_view: number;
}

interface Vehicle {
  id: string;
  title: string;
  make: string;
  model: string;
  year: number;
  price: number;
  body_type: string;
  location: string;
  condition: string;
  transmission: string;
  fuel_type: string;
  images: string[];
  created_at: string;
  specs?: {
    color?: string;
  };
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const body = await req.json().catch(() => ({}));
    const { saved_search_id, user_id } = body;

    // Get saved searches to update
    let query = supabase.from('saved_searches').select('*');
    
    if (saved_search_id) {
      query = query.eq('id', saved_search_id);
    } else if (user_id) {
      query = query.eq('user_id', user_id);
    }
    // If no filters, update all saved searches (for background job)

    const { data: savedSearches, error: searchesError } = await query;

    if (searchesError) {
      throw searchesError;
    }

    // Get all active vehicles
    const { data: vehicles, error: vehiclesError } = await supabase
      .from('vehicles')
      .select('*')
      .eq('status', 'active')
      .or('is_deleted.is.null,is_deleted.eq.false');

    if (vehiclesError) {
      throw vehiclesError;
    }

    const updates: { id: string; current_match_count: number; new_matches_since_view: number }[] = [];

    // Calculate match count for each saved search
    for (const search of savedSearches || []) {
      const matchingVehicles = (vehicles || []).filter(vehicle => 
        vehicleMatchesSearch(vehicle, search)
      );
      
      const currentCount = matchingVehicles.length;
      const previousCount = search.current_match_count || 0;
      
      // Calculate new matches since last view
      let newMatchesSinceView = search.new_matches_since_view || 0;
      if (currentCount > previousCount) {
        newMatchesSinceView += (currentCount - previousCount);
      }

      updates.push({
        id: search.id,
        current_match_count: currentCount,
        new_matches_since_view: newMatchesSinceView,
      });
    }

    // Batch update all saved searches
    for (const update of updates) {
      await supabase
        .from('saved_searches')
        .update({
          last_match_count: update.current_match_count, // Store previous as last
          current_match_count: update.current_match_count,
          new_matches_since_view: update.new_matches_since_view,
          updated_at: new Date().toISOString(),
        })
        .eq('id', update.id);
    }

    return new Response(
      JSON.stringify({ 
        success: true, 
        updated_count: updates.length,
        updates: updates,
      }),
      { headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );

  } catch (error) {
    console.error('Error updating saved search counts:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );
  }
});

function vehicleMatchesSearch(vehicle: Vehicle, search: SavedSearch): boolean {
  const filters = search.filters || {};
  
  // Check search query
  if (search.search_query) {
    const query = search.search_query.toLowerCase();
    const searchableText = `${vehicle.title} ${vehicle.make} ${vehicle.model}`.toLowerCase();
    if (!searchableText.includes(query)) {
      return false;
    }
  }

  // Check make filter
  if (filters.make && filters.make !== 'All Makes') {
    if (vehicle.make !== filters.make) return false;
  }

  // Check body type filter
  if (filters.bodyType && filters.bodyType !== 'All Types') {
    if (vehicle.body_type !== filters.bodyType) return false;
  }

  // Check location filter
  if (filters.location && filters.location !== 'All Locations') {
    if (vehicle.location !== filters.location) return false;
  }

  // Check condition filter
  if (filters.condition && filters.condition !== 'All') {
    if (vehicle.condition !== filters.condition) return false;
  }

  // Check transmission filter
  if (filters.transmission && filters.transmission !== 'All') {
    if (vehicle.transmission !== filters.transmission) return false;
  }

  // Check fuel type filter
  if (filters.fuelType && filters.fuelType !== 'All') {
    if (vehicle.fuel_type !== filters.fuelType) return false;
  }

  // Check color filter
  if (filters.color && filters.color !== 'All Colors') {
    const vehicleColor = vehicle.specs?.color?.toLowerCase() || '';
    const filterColor = filters.color.toLowerCase();
    if (!vehicleColor.includes(filterColor)) {
      return false;
    }
  }

  // Check min price filter
  if (filters.minPrice) {
    const minPrice = parseInt(filters.minPrice);
    if (!isNaN(minPrice) && vehicle.price < minPrice) {
      return false;
    }
  }

  // Check max price filter
  if (filters.maxPrice) {
    const maxPrice = parseInt(filters.maxPrice);
    if (!isNaN(maxPrice) && vehicle.price > maxPrice) {
      return false;
    }
  }

  // Check min year filter
  if (filters.minYear && filters.minYear !== 'Any') {
    const minYear = parseInt(filters.minYear);
    if (!isNaN(minYear) && vehicle.year < minYear) {
      return false;
    }
  }

  // Check max year filter
  if (filters.maxYear && filters.maxYear !== 'Any') {
    const maxYear = parseInt(filters.maxYear);
    if (!isNaN(maxYear) && vehicle.year > maxYear) {
      return false;
    }
  }

  // Check legacy price range filter
  if (filters.priceRange && filters.priceRange !== 'Any Price' && !filters.minPrice && !filters.maxPrice) {
    const price = vehicle.price;
    switch (filters.priceRange) {
      case 'Under $30,000':
        if (price >= 30000) return false;
        break;
      case '$30,000 - $50,000':
        if (price < 30000 || price > 50000) return false;
        break;
      case '$50,000 - $80,000':
        if (price < 50000 || price > 80000) return false;
        break;
      case '$80,000 - $120,000':
        if (price < 80000 || price > 120000) return false;
        break;
      case '$120,000 - $200,000':
        if (price < 120000 || price > 200000) return false;
        break;
      case 'Over $200,000':
        if (price <= 200000) return false;
        break;
    }
  }

  return true;
}
